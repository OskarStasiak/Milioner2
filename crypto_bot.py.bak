import time
import json
import os
import logging
from datetime import datetime, timedelta
from dotenv import load_dotenv
from coinbase.rest import RESTClient
import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler
import tensorflow as tf
from websocket_client import CoinbaseWebSocket
import threading
import websocket

# Konfiguracja loggera
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

# Dodaj handler do pliku
file_handler = logging.FileHandler('crypto_bot.log')
file_handler.setLevel(logging.INFO)

# Dodaj handler do konsoli
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)

# Format logów
formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
file_handler.setFormatter(formatter)
console_handler.setFormatter(formatter)

# Dodaj handlery do loggera
logger.addHandler(file_handler)
logger.addHandler(console_handler)

# Załaduj zmienne środowiskowe
load_dotenv('production.env')

# Konfiguracja API
with open('cdp_api_key.json', 'r') as f:
    api_keys = json.load(f)
    API_KEY = api_keys['api_key_id']
    API_SECRET = api_keys['api_key_secret']

# Parametry handlowe
TRADING_PAIRS = ['ETH-USDC', 'BTC-USDC', 'SOL-USDC', 'DOGE-USDC', 'XRP-USDC', 'MATIC-USDC', 'LINK-USDC']
TRADE_VALUE_USDC = float(os.getenv('TRADE_VALUE_USDC', 50))  # Zmniejszona wartość pojedynczej transakcji
MAX_TOTAL_EXPOSURE = float(os.getenv('MAX_TOTAL_EXPOSURE', 200))  # Zwiększone maksymalne narażenie
MAX_POSITION_SIZE = float(os.getenv('MAX_POSITION_SIZE', 0.05))  # Zwiększony maksymalny rozmiar pozycji
PRICE_THRESHOLD_BUY = float(os.getenv('PRICE_THRESHOLD_BUY', 2500))  # Obniżony próg kupna
PRICE_THRESHOLD_SELL = float(os.getenv('PRICE_THRESHOLD_SELL', 2800))  # Podwyższony próg sprzedaży
MIN_PROFIT_PERCENT = float(os.getenv('MIN_PROFIT_PERCENT', 0.3))  # Zmniejszony minimalny zysk
MAX_LOSS_PERCENT = float(os.getenv('MAX_LOSS_PERCENT', 1.0))  # Zmniejszona maksymalna strata

# Nowe parametry dla stop-loss i take-profit
STOP_LOSS_PERCENT = float(os.getenv('STOP_LOSS_PERCENT', 0.8))  # Zmniejszony stop-loss
TAKE_PROFIT_PERCENT = float(os.getenv('TAKE_PROFIT_PERCENT', 1.0))  # Zmniejszony take-profit
TRAILING_STOP_PERCENT = float(os.getenv('TRAILING_STOP_PERCENT', 0.3))  # Zmniejszony trailing stop

# Parametry podwajania zysków
PROFIT_DOUBLING_DAYS = 2  # Co 2 dni podwajamy zyski
INITIAL_PROFIT_TARGET = 1.0  # Początkowy cel zysku w procentach
MAX_PROFIT_TARGET = 15.0  # Maksymalny cel zysku w procentach
PROFIT_MULTIPLIER = 2.5  # Mnożnik do podwajania zysków

# Parametry zarządzania kapitałem
CAPITAL_ALLOCATION = {
    'ETH-USDC': 0.20,  # Zwiększony udział ETH
    'BTC-USDC': 0.15,
    'SOL-USDC': 0.15,
    'DOGE-USDC': 0.10,
    'XRP-USDC': 0.15,
    'MATIC-USDC': 0.15,
    'LINK-USDC': 0.10,
    'RESERVE': 0.0
}

MIN_TRADE_SIZE_USDC = 5  # Zmniejszona minimalna wielkość zlecenia
MAX_TRADES_PER_DAY = 20   # Zwiększona maksymalna liczba transakcji dziennie

# Parametry zarządzania zyskami
MIN_PROFIT_TARGET = 0.5  # Minimalny cel zysku w procentach
MAX_PROFIT_TARGET = 10.0  # Maksymalny cel zysku w procentach
VOLATILITY_MULTIPLIER = 2.5  # Mnożnik zmienności do obliczania celu zysku
TREND_STRENGTH_MULTIPLIER = 2.0  # Mnożnik siły trendu do obliczania celu zysku

# Minimalny rozmiar zlecenia dla każdej pary
MIN_ORDER_SIZE_USDC = {
    'ETH-USDC': 10.0,
    'BTC-USDC': 10.0,
    'SOL-USDC': 10.0,
    'DOGE-USDC': 10.0,
    'XRP-USDC': 10.0,
    'MATIC-USDC': 10.0,
    'LINK-USDC': 10.0
}

# Parametry handlowe dla różnych par
TRADING_PARAMS = {
    'ETH-USDC': {
        'rsi_threshold': 45,  # Zmniejszony próg RSI
        'macd_threshold': -0.1,  # Zmniejszony próg MACD
        'ma_threshold': -0.1,
        'volatility_threshold': 0.8,
        'profit_target': 0.8,
        'stop_loss': 0.4,
        'position_size': 0.20
    },
    'BTC-USDC': {
        'rsi_threshold': 45,
        'macd_threshold': -0.1,
        'ma_threshold': -0.1,
        'volatility_threshold': 0.8,
        'profit_target': 0.8,
        'stop_loss': 0.4,
        'position_size': 0.15
    },
    'SOL-USDC': {
        'rsi_threshold': 45,
        'macd_threshold': -0.1,
        'ma_threshold': -0.1,
        'volatility_threshold': 1.0,
        'profit_target': 1.0,
        'stop_loss': 0.5,
        'position_size': 0.15
    },
    'DOGE-USDC': {
        'rsi_threshold': 50,
        'macd_threshold': -0.1,
        'ma_threshold': -0.1,
        'volatility_threshold': 1.5,
        'profit_target': 1.5,
        'stop_loss': 0.8,
        'position_size': 0.10
    },
    'XRP-USDC': {
        'rsi_threshold': 45,
        'macd_threshold': -0.1,
        'ma_threshold': -0.1,
        'volatility_threshold': 1.0,
        'profit_target': 1.0,
        'stop_loss': 0.5,
        'position_size': 0.15
    },
    'MATIC-USDC': {
        'rsi_threshold': 45,
        'macd_threshold': -0.1,
        'ma_threshold': -0.1,
        'volatility_threshold': 1.0,
        'profit_target': 1.0,
        'stop_loss': 0.5,
        'position_size': 0.15
    },
    'LINK-USDC': {
        'rsi_threshold': 45,
        'macd_threshold': -0.1,
        'ma_threshold': -0.1,
        'volatility_threshold': 1.0,
        'profit_target': 1.0,
        'stop_loss': 0.5,
        'position_size': 0.10
    }
}

# Inicjalizacja API
client = RESTClient(api_key=API_KEY, api_secret=API_SECRET)

# Inicjalizacja WebSocket dla wszystkich par
ws = CoinbaseWebSocket(API_KEY, API_SECRET, TRADING_PAIRS)

# Globalne zmienne do przechowywania danych w czasie rzeczywistym
market_data = {}
for pair in TRADING_PAIRS:
    market_data[pair] = {
        'current_price': None,
        'order_book': {'bids': [], 'asks': []},
        'last_trade': None,
        'price_history': [],
        'last_buy_price': None,
        'last_sell_price': None,
        'trade_history': [],  # Inicjalizacja pustej historii transakcji
        'highest_price': None
    }
    logging.info(f"Inicjalizacja danych dla {pair} - historia transakcji wyczyszczona")

def on_ws_message(data):
    """Obsługa wiadomości z WebSocket."""
    try:
        if data['type'] == 'ticker':
            product_id = data.get('product_id')
            if product_id not in TRADING_PAIRS:
                return
                
            price = float(data.get('price', 0))
            if price > 0:
                market_data[product_id]['current_price'] = price
                market_data[product_id]['price_history'].append({
                    'timestamp': datetime.utcnow(),
                    'price': price
                })
                # Zachowaj tylko ostatnie 1000 cen
                if len(market_data[product_id]['price_history']) > 1000:
                    market_data[product_id]['price_history'].pop(0)
                logging.info(f"Aktualna cena {product_id}: {price}")
            
        elif data['type'] == 'snapshot':
            product_id = data.get('product_id')
            if product_id not in TRADING_PAIRS:
                return
                
            market_data[product_id]['order_book']['bids'] = data.get('bids', [])
            market_data[product_id]['order_book']['asks'] = data.get('asks', [])
            logging.info(f"Zaktualizowano książkę zleceń dla {product_id}: {len(market_data[product_id]['order_book']['bids'])} bidów, {len(market_data[product_id]['order_book']['asks'])} asków")
            
        elif data['type'] == 'l2update':
            product_id = data.get('product_id')
            if product_id not in TRADING_PAIRS:
                return
                
            changes = data.get('changes', [])
            for change in changes:
                side, price, size = change
                if side == 'buy':
                    market_data[product_id]['order_book']['bids'] = [b for b in market_data[product_id]['order_book']['bids'] if b[0] != price]
                    if float(size) > 0:
                        market_data[product_id]['order_book']['bids'].append([price, size])
                else:
                    market_data[product_id]['order_book']['asks'] = [a for a in market_data[product_id]['order_book']['asks'] if a[0] != price]
                    if float(size) > 0:
                        market_data[product_id]['order_book']['asks'].append([price, size])
            
            # Sortowanie książki zleceń
            market_data[product_id]['order_book']['bids'].sort(key=lambda x: float(x[0]), reverse=True)
            market_data[product_id]['order_book']['asks'].sort(key=lambda x: float(x[0]))
            
    except Exception as e:
        logging.error(f"Błąd podczas przetwarzania wiadomości WebSocket: {e}")

def calculate_market_depth(product_id):
    """Oblicza głębokość rynku na podstawie książki zleceń."""
    try:
        if product_id not in market_data:
            return None
            
        total_bids = sum(float(bid[1]) for bid in market_data[product_id]['order_book']['bids'][:10])  # Top 10 bidów
        total_asks = sum(float(ask[1]) for ask in market_data[product_id]['order_book']['asks'][:10])  # Top 10 asków
        
        return {
            'bids_volume': total_bids,
            'asks_volume': total_asks,
            'ratio': total_bids / total_asks if total_asks > 0 else 0
        }
    except Exception as e:
        logging.error(f"Błąd podczas obliczania głębokości rynku dla {product_id}: {e}")
        return None

def calculate_volatility(historical_data, window=20):
    """Oblicza zmienność ceny."""
    try:
        if isinstance(historical_data, pd.DataFrame):
            prices = historical_data['price'].values
        else:
            prices = historical_data
            
        # Oblicz procentowe zmiany
        returns = np.diff(prices) / prices[:-1]
        
        # Oblicz odchylenie standardowe
        volatility = np.std(returns[-window:]) * 100  # Konwersja na procenty
        
        return float(volatility)
    except Exception as e:
        logger.error(f"Błąd podczas obliczania zmienności: {e}")
        return 0.0  # Domyślna wartość w przypadku błędu

def calculate_rsi(prices, period=14):
    """Oblicza wskaźnik RSI."""
    try:
        if isinstance(prices, pd.Series):
            prices = prices.values
            
        delta = np.diff(prices)
        gain = np.where(delta > 0, delta, 0)
        loss = np.where(delta < 0, -delta, 0)
        
        avg_gain = np.mean(gain[:period])
        avg_loss = np.mean(loss[:period])
        
        for i in range(period, len(delta)):
            avg_gain = (avg_gain * (period - 1) + gain[i]) / period
            avg_loss = (avg_loss * (period - 1) + loss[i]) / period
            
        rs = avg_gain / avg_loss if avg_loss != 0 else 0
        rsi = 100 - (100 / (1 + rs))
        
        return float(rsi)  # Zwracamy pojedynczą wartość float
    except Exception as e:
        logger.error(f"Błąd podczas obliczania RSI: {e}")
        return 50.0  # Domyślna wartość w przypadku błędu

def calculate_macd(prices, fast=12, slow=26, signal=9):
    """Oblicza wskaźnik MACD."""
    try:
        if isinstance(prices, pd.Series):
            prices = prices.values
            
        # Oblicz EMA
        ema_fast = np.mean(prices[:fast])
        ema_slow = np.mean(prices[:slow])
        
        # Oblicz MACD
        for i in range(fast, len(prices)):
            ema_fast = (prices[i] * (2 / (fast + 1))) + (ema_fast * (1 - (2 / (fast + 1))))
            
        for i in range(slow, len(prices)):
            ema_slow = (prices[i] * (2 / (slow + 1))) + (ema_slow * (1 - (2 / (slow + 1))))
            
        macd = ema_fast - ema_slow
        
        # Oblicz linię sygnału
        signal_line = np.mean([macd] * signal)
        
        # Oblicz histogram
        histogram = macd - signal_line
        
        return float(macd), float(signal_line), float(histogram)
    except Exception as e:
        logger.error(f"Błąd podczas obliczania MACD: {e}")
        return 0.0, 0.0, 0.0  # Domyślne wartości w przypadku błędu

def calculate_moving_averages(prices, short_period=20, long_period=50):
    """Oblicza średnie kroczące."""
    try:
        if isinstance(prices, pd.Series):
            prices = prices.values
            
        # Oblicz krótkoterminową średnią kroczącą
        ma_short = np.mean(prices[-short_period:])
        
        # Oblicz długoterminową średnią kroczącą
        ma_long = np.mean(prices[-long_period:])
        
        return float(ma_short), float(ma_long)
    except Exception as e:
        logger.error(f"Błąd podczas obliczania średnich kroczących: {e}")
        return 0.0, 0.0  # Domyślne wartości w przypadku błędu

def get_available_balance(currency):
    """Pobiera dostępne saldo dla danej waluty, ignorując środki w stakingu."""
    try:
        accounts = client.get_accounts().accounts
        for account in accounts:
            if account.currency == currency:
                if hasattr(account, 'available_balance'):
                    if isinstance(account.available_balance, dict):
                        return float(account.available_balance.get('value', 0))
                    else:
                        return float(account.available_balance.value)
        return 0
    except Exception as e:
        logger.error(f"Błąd podczas pobierania salda {currency}: {e}")
        return 0

def get_usdc_balance():
    """Pobierz saldo USDC."""
    try:
        accounts = client.get_accounts().accounts
        for account in accounts:
            if account.currency == 'USDC':
                balance = account.available_balance
                if balance:
                    if isinstance(balance, dict):
                        return float(balance.get('value', 0))
                    else:
                        return float(balance.value)
        return 0
    except Exception as e:
        logging.error(f"Błąd podczas pobierania salda USDC: {e}")
        return 0

def get_usd_balance():
    """Pobierz saldo USD."""
    try:
        accounts = client.get_accounts().accounts
        for account in accounts:
            if account.currency == 'USD':
                balance = account.available_balance
                if balance:
                    if isinstance(balance, dict):
                        return float(balance.get('value', 0))
                    else:
                        return float(balance.value)
        return 0
    except Exception as e:
        logging.error(f"Błąd podczas pobierania salda USD: {e}")
        return 0

def get_crypto_balance(crypto_symbol):
    """Pobierz saldo danej kryptowaluty."""
    try:
        accounts = client.get_accounts().accounts
        for account in accounts:
            if account.currency == crypto_symbol:
                balance = account.available_balance
                if balance:
                    if isinstance(balance, dict):
                        return float(balance.get('value', 0))
                    else:
                        return float(balance.value)
        return 0
    except Exception as e:
        logging.error(f"Błąd podczas pobierania salda {crypto_symbol}: {e}")
        return 0

def should_trade(current_price, historical_data):
    """Decyduje, czy należy wykonać transakcję na podstawie analizy technicznej."""
    try:
        if historical_data is None or len(historical_data) < 24:
            logging.info("Za mało danych historycznych do analizy")
            return False
            
        # Oblicz wskaźniki techniczne
        rsi = calculate_rsi(historical_data)
        macd, signal, hist = calculate_macd(historical_data)
        ma_short, ma_long = calculate_moving_averages(historical_data)
        
        if macd is None or ma_short is None:
            logging.info("Nie można obliczyć wskaźników technicznych")
            return False
            
        # Konwertuj wartości na float
        current_price = float(current_price)
        
        # Loguj wskaźniki
        logging.info(f"RSI: {rsi:.2f}")
        logging.info(f"MACD: {macd:.2f}, Signal: {signal:.2f}, Hist: {hist:.2f}")
        logging.info(f"MA20: {ma_short:.2f}, MA50: {ma_long:.2f}")
        
        # Oblicz zmienność ceny
        price_volatility = calculate_volatility(historical_data)
        logging.info(f"Zmienność ceny: {price_volatility:.2f}%")
        
        # Bardzo selektywne warunki kupna - tylko silne sygnały
        if (current_price > ma_short and rsi < 45 and macd > signal and hist > 0) or \
           (current_price > ma_long and rsi < 40 and price_volatility > 0.5) or \
           (current_price > ma_short and hist > 0 and rsi < 50 and price_volatility > 0.3):
            logging.info("SILNY SYGNAŁ KUPNA - Wykryto potencjalny wzrost")
            return True
            
        # Bardzo selektywne warunki sprzedaży - tylko przy pewnych sygnałach
        if (current_price < ma_short and rsi > 55) or \
           (current_price < ma_long and rsi > 50) or \
           (current_price < ma_short and hist < 0 and rsi > 45 and price_volatility > 0.8):
            logging.info("SILNY SYGNAŁ SPRZEDAŻY - Realizacja zysku lub ograniczenie straty")
            return True
            
        return False
        
    except Exception as e:
        logging.error(f"Błąd podczas analizy warunków handlowych: {e}")
        return False

def init_ai_model():
    """Inicjalizacja modelu AI do przewidywania cen."""
    model = tf.keras.Sequential([
        tf.keras.layers.LSTM(50, return_sequences=True, input_shape=(60, 1)),
        tf.keras.layers.LSTM(50, return_sequences=False),
        tf.keras.layers.Dense(25),
        tf.keras.layers.Dense(1)
    ])
    model.compile(optimizer='adam', loss='mean_squared_error')
    return model

def get_historical_data(product_id):
    """Pobierz historyczne dane cenowe dla danej pary."""
    try:
        # Pobierz świeczki (candles) dla danego produktu
        end_time = datetime.utcnow()
        start_time = end_time - timedelta(days=3)  # Pobierz dane z ostatnich 3 dni
        
        # Konwertuj daty na timestamp w sekundach
        start_timestamp = int(start_time.timestamp())
        end_timestamp = int(end_time.timestamp())
        
        # Użyj prawidłowej metody API
        response = client.get_candles(
            product_id=product_id,
            start=start_timestamp,
            end=end_timestamp,
            granularity="ONE_HOUR"
        )
        
        if not response or not hasattr(response, 'candles'):
            logger.warning(f"Brak danych historycznych dla {product_id}")
            return None
            
        # Konwertuj dane do DataFrame
        data = []
        for candle in response.candles:
            try:
                data.append({
                    'timestamp': datetime.fromtimestamp(int(candle.start)),
                    'price': float(candle.close),
                    'size': float(candle.volume)
                })
            except (AttributeError, ValueError) as e:
                logger.warning(f"Pominięto nieprawidłową świeczkę dla {product_id}: {e}")
                continue
        
        if not data:
            logger.warning(f"Brak prawidłowych danych historycznych dla {product_id}")
            return None
            
        df = pd.DataFrame(data)
        df['timestamp'] = pd.to_datetime(df['timestamp'])
        
        logger.info(f"Pobrano {len(df)} świeczek dla {product_id}")
        return df
        
    except Exception as e:
        logger.error(f"Błąd podczas pobierania historycznych danych dla {product_id}: {e}")
        return None

def prepare_data_for_ai(historical_data):
    """Przygotuj dane dla modelu AI."""
    if not historical_data:
        return None
    
    try:
        # Normalizacja danych
        scaler = MinMaxScaler()
        scaled_data = scaler.fit_transform(historical_data['price'].values.reshape(-1, 1))
        
        # Przygotowanie sekwencji
        X, y = [], []
        for i in range(60, len(scaled_data)):
            X.append(scaled_data[i-60:i, 0])
            y.append(scaled_data[i, 0])
        
        return np.array(X), np.array(y), scaler
    except Exception as e:
        logging.error(f"Błąd podczas przygotowywania danych dla AI: {e}")
        return None

def predict_price(model, X, scaler):
    """Przewiduj przyszłą cenę."""
    try:
        prediction = model.predict(X)
        return scaler.inverse_transform(prediction)[0][0]
    except Exception as e:
        logging.error(f"Błąd podczas przewidywania ceny: {e}")
        return None

def analyze_market_trend(historical_data):
    """Analizuj trend rynkowy."""
    if historical_data is None or historical_data.empty:
        return "neutral"
    
    try:
        # Oblicz wskaźniki techniczne
        current_price = float(historical_data['price'].iloc[-1])
        ma_short, ma_long = calculate_moving_averages(historical_data['price'])
        rsi = calculate_rsi(historical_data['price'])
        
        # Sprawdź czy wartości nie są NaN
        if any(pd.isna(x) for x in [current_price, ma_short, ma_long, rsi]):
            return "neutral"
        
        # Analiza trendu na podstawie wielu wskaźników
        if current_price > ma_short and ma_short > ma_long and rsi > 50:
            return "bullish"
        elif current_price < ma_short and ma_short < ma_long and rsi < 50:
            return "bearish"
        else:
            return "neutral"
    except Exception as e:
        logger.error(f"Błąd podczas analizy trendu: {e}")
        return "neutral"

def suggest_thresholds(current_price, trend, predicted_price=None):
    """Sugeruj progi kupna/sprzedaży na podstawie analizy AI."""
    try:
        if predicted_price:
            # Jeśli mamy przewidywanie ceny, użyj go do ustawienia progów
            price_range = abs(predicted_price - current_price)
            if trend == "bullish":
                return {
                    'buy': current_price * 0.95,  # 5% poniżej aktualnej ceny
                    'sell': predicted_price * 1.05  # 5% powyżej przewidywanej ceny
                }
            elif trend == "bearish":
                return {
                    'buy': predicted_price * 0.95,  # 5% poniżej przewidywanej ceny
                    'sell': current_price * 1.05  # 5% powyżej aktualnej ceny
                }
            else:
                return {
                    'buy': min(current_price, predicted_price) * 0.95,
                    'sell': max(current_price, predicted_price) * 1.05
                }
        else:
            # Jeśli nie mamy przewidywania, użyj standardowych progów
            if trend == "bullish":
                return {
                    'buy': current_price * 0.95,  # 5% poniżej aktualnej ceny
                    'sell': current_price * 1.15  # 15% powyżej aktualnej ceny
                }
            elif trend == "bearish":
                return {
                    'buy': current_price * 0.85,  # 15% poniżej aktualnej ceny
                    'sell': current_price * 1.05  # 5% powyżej aktualnej ceny
                }
            else:
                return {
                    'buy': current_price * 0.90,  # 10% poniżej aktualnej ceny
                    'sell': current_price * 1.10  # 10% powyżej aktualnej ceny
                }
    except Exception as e:
        logging.error(f"Błąd podczas sugerowania progów: {e}")
        return {
            'buy': current_price * 0.90,
            'sell': current_price * 1.10
        }

def get_account_balance():
    """Pobierz stan konta."""
    try:
        accounts = client.get_accounts().accounts
        usdc_balance = 0
        eth_balance = 0
        for account in accounts:
            if account.currency == 'USDC':
                balance = account.available_balance
                if balance:
                    if isinstance(balance, dict):
                        usdc_balance = float(balance.get('value', 0))
                    else:
                        usdc_balance = float(balance.value)
            elif account.currency == 'ETH':
                balance = account.available_balance
                if balance:
                    if isinstance(balance, dict):
                        eth_balance = float(balance.get('value', 0))
                    else:
                        eth_balance = float(balance.value)
        return usdc_balance, eth_balance
    except Exception as e:
        logging.error(f"Błąd podczas pobierania stanu konta: {e}")
        raise

def get_product_ticker(product_id):
    """Pobiera aktualną cenę dla danej pary handlowej."""
    try:
        # Użyj prawidłowej metody API dla Coinbase Advanced
        product = client.get_product(product_id)
        if product and hasattr(product, 'price'):
            return float(product.price)
        elif product and hasattr(product, 'last_trade_price'):
            return float(product.last_trade_price)
        return None
    except Exception as e:
        logger.error(f"Błąd podczas pobierania aktualnej ceny dla {product_id}: {e}")
        return None

def check_total_exposure():
    """Sprawdza całkowitą ekspozycję portfela."""
    try:
        total_exposure = 0
        for pair in TRADING_PAIRS:
            if pair not in market_data:
                continue
                
            trade_history = market_data[pair]['trade_history']
            if not trade_history:
                continue
                
            # Znajdź ostatnią transakcję kupna
            last_buy = None
            for trade in reversed(trade_history):
                if trade['type'] == 'buy':
                    last_buy = trade
                    break
                    
            if last_buy:
                # Oblicz wartość pozycji
                position_value = float(last_buy['amount']) * float(last_buy['price'])
                total_exposure += position_value
                
        return total_exposure
        
    except Exception as e:
        logger.error(f"Błąd podczas sprawdzania całkowitej ekspozycji: {e}")
        return 0

def can_open_new_position():
    """Sprawdza czy można otworzyć nową pozycję."""
    try:
        # Sprawdź całkowitą ekspozycję
        total_exposure = check_total_exposure()
        if total_exposure >= MAX_TOTAL_EXPOSURE:
            logger.warning(f"Przekroczono maksymalną ekspozycję: {total_exposure:.2f} USDC (limit: {MAX_TOTAL_EXPOSURE:.2f} USDC)")
            return False
            
        # Sprawdź dzienny P&L
        daily_pnl = check_daily_pnl()
        pnl_limit = calculate_pnl_limit()
        if daily_pnl < 0 and abs(daily_pnl) > pnl_limit:
            logger.warning(f"Przekroczono dzienny limit straty: {daily_pnl:.2f} USDC (limit: {pnl_limit:.2f} USDC)")
            return False
            
        # Sprawdź liczbę otwartych pozycji
        open_positions = 0
        for pair in TRADING_PAIRS:
            if pair in market_data and market_data[pair].get('in_position', False):
                open_positions += 1
                
        if open_positions >= MAX_OPEN_POSITIONS:
            logger.warning(f"Przekroczono maksymalną liczbę otwartych pozycji: {open_positions} (limit: {MAX_OPEN_POSITIONS})")
            return False
            
        return True
        
    except Exception as e:
        logger.error(f"Błąd podczas sprawdzania możliwości otwarcia nowej pozycji: {e}")
        return False

def calculate_profit_target(product_id, historical_data):
    """Oblicza dynamiczny cel zysku na podstawie analizy rynku."""
    try:
        if historical_data is None or len(historical_data) < 24:
            return MIN_PROFIT_TARGET
            
        # Oblicz zmienność ceny
        volatility = calculate_volatility(historical_data)
        
        # Oblicz siłę trendu
        rsi = calculate_rsi(historical_data)
        macd, signal, hist = calculate_macd(historical_data)
        ma_short, ma_long = calculate_moving_averages(historical_data)
        
        if macd is None or ma_short is None:
            return MIN_PROFIT_TARGET
            
        # Określ siłę trendu
        trend_strength = 1.0
        if current_price > ma_short and ma_short > ma_long:
            trend_strength = TREND_STRENGTH_MULTIPLIER
        elif current_price < ma_short and ma_short < ma_long:
            trend_strength = 0.5
            
        # Oblicz cel zysku na podstawie zmienności i trendu
        profit_target = volatility * VOLATILITY_MULTIPLIER * trend_strength
        
        # Ogranicz cel zysku do rozsądnych wartości
        profit_target = max(MIN_PROFIT_TARGET, min(profit_target, MAX_PROFIT_TARGET))
        
        logger.info(f"Obliczony cel zysku dla {product_id}: {profit_target:.2f}% (zmienność: {volatility:.2f}%, siła trendu: {trend_strength:.2f})")
        return profit_target
        
    except Exception as e:
        logger.error(f"Błąd podczas obliczania celu zysku: {e}")
        return MIN_PROFIT_TARGET

def should_take_profit(product_id, current_price, historical_data):
    """Sprawdza czy należy zrealizować zysk na podstawie dynamicznej analizy rynku."""
    try:
        last_buy_price = market_data[product_id].get('last_buy_price')
        if not last_buy_price:
            return False
            
        # Konwertuj wartości na float
        current_price = float(current_price)
        last_buy_price = float(last_buy_price)
            
        # Oblicz procentową zmianę ceny
        price_change_percent = ((current_price - last_buy_price) / last_buy_price) * 100
        
        # Pobierz dynamiczny cel zysku
        profit_target = calculate_profit_target(product_id, historical_data)
        
        # Sprawdź czy osiągnięto cel zysku
        if price_change_percent >= profit_target:
            logging.info(f"Osiągnięto cel zysku {profit_target:.2f}% dla {product_id} (zmiana: {price_change_percent:.2f}%)")
            return True
            
        # Sprawdź czy trend się odwraca
        rsi = calculate_rsi(historical_data)
        macd, signal, hist = calculate_macd(historical_data)
        
        # Konwertuj wskaźniki na float
        rsi = float(rsi.iloc[-1]) if hasattr(rsi, 'iloc') else float(rsi[-1])
        hist = float(hist.iloc[-1]) if hasattr(hist, 'iloc') else float(hist[-1])
        
        if price_change_percent > 0 and rsi > 70 and hist < 0:
            logging.info(f"Trend się odwraca - realizacja zysku {price_change_percent:.2f}% dla {product_id}")
            return True
            
        return False
        
    except Exception as e:
        logging.error(f"Błąd podczas sprawdzania realizacji zysku: {e}")
        return False

def check_stop_loss_take_profit(product_id, current_price):
    """Sprawdza warunki stop-loss i take-profit dla danej pozycji."""
    try:
        if product_id not in market_data:
            return False
            
        last_buy_price = market_data[product_id].get('last_buy_price')
        if not last_buy_price:
            return False
            
        # Konwertuj wartości na float
        current_price = float(current_price)
        last_buy_price = float(last_buy_price)
            
        # Pobierz dane historyczne
        historical_data = market_data[product_id].get('price_history')
        
        # Sprawdź stop-loss
        price_change_percent = ((current_price - last_buy_price) / last_buy_price) * 100
        if price_change_percent <= -STOP_LOSS_PERCENT:
            logging.info(f"STOP-LOSS dla {product_id} przy cenie {current_price} (zmiana: {price_change_percent:.2f}%)")
            return True
            
        # Sprawdź dynamiczny take-profit
        if should_take_profit(product_id, current_price, historical_data):
            return True
            
        # Sprawdź trailing stop
        highest_price = market_data[product_id].get('highest_price', last_buy_price)
        highest_price = float(highest_price)
        
        if current_price > highest_price:
            market_data[product_id]['highest_price'] = current_price
        elif current_price < highest_price * (1 - TRAILING_STOP_PERCENT/100):
            logging.info(f"TRAILING-STOP dla {product_id} przy cenie {current_price} (najwyższa: {highest_price})")
            return True
            
        return False
    except Exception as e:
        logging.error(f"Błąd podczas sprawdzania stop-loss/take-profit: {e}")
        return False

def get_available_capital_for_pair(product_id):
    """Oblicza dostępny kapitał dla danej pary handlowej."""
    try:
        total_capital = get_usdc_balance()
        allocation = CAPITAL_ALLOCATION.get(product_id, 0)
        return total_capital * allocation
    except Exception as e:
        logger.error(f"Błąd podczas obliczania dostępnego kapitału: {e}")
        return 0

def can_trade_today(product_id):
    """Sprawdza czy można handlować daną parą dzisiaj."""
    try:
        if product_id not in market_data:
            return True
            
        trade_history = market_data[product_id]['trade_history']
        if not trade_history:
            return True
            
        # Sprawdź liczbę transakcji dzisiaj
        today = datetime.utcnow().date()
        today_trades = 0
        
        for trade in trade_history:
            if not isinstance(trade['timestamp'], datetime):
                continue
                
            trade_date = trade['timestamp'].date()
            if trade_date == today:
                today_trades += 1
                
        if today_trades >= MAX_TRADES_PER_DAY:
            logger.warning(f"Przekroczono dzienny limit transakcji dla {product_id}: {today_trades} (limit: {MAX_TRADES_PER_DAY})")
            return False
            
        return True
        
    except Exception as e:
        logger.error(f"Błąd podczas sprawdzania możliwości handlu dzisiaj: {e}")
        return False

def calculate_trade_size(product_id, current_price, sentiment):
    """Oblicza optymalną wielkość zlecenia na podstawie dostępnych środków."""
    try:
        # Pobierz dostępne środki
        if product_id.endswith('USDC'):
            available_capital = get_available_balance('USDC')
        else:
            available_capital = get_available_balance('USD')
            
        # Pobierz historię transakcji
        trade_history = market_data[product_id]['trade_history']
        
        # Oblicz dzienny P&L
        daily_pnl = 0
        today = datetime.utcnow().date()
        for trade in trade_history:
            if trade['timestamp'].date() == today:
                if trade['type'] == 'sell':
                    daily_pnl += (trade['price'] - market_data[product_id]['last_buy_price']) * trade['amount']
                else:
                    daily_pnl -= trade['price'] * trade['amount']
        
        # Dostosuj rozmiar pozycji na podstawie sentymentu
        base_size = min(available_capital * 0.2, MAX_POSITION_SIZE)  # Maksymalnie 20% dostępnych środków
        
        # Zmniejsz rozmiar jeśli sentyment jest negatywny
        if sentiment < -0.5:
            base_size *= 0.5
        elif sentiment < 0:
            base_size *= 0.75
            
        # Zmniejsz rozmiar jeśli dzienny P&L jest ujemny
        if daily_pnl < 0:
            base_size *= 0.5
            
        # Sprawdź minimalny rozmiar zlecenia
        min_size = MIN_ORDER_SIZE_USDC.get(product_id, 10.0)
        if base_size < min_size:
            logger.info(f"Za mało kapitału na zlecenie dla {product_id} (min: {min_size} USDC)")
            return 0
            
        return base_size
        
    except Exception as e:
        logger.error(f"Błąd podczas obliczania rozmiaru pozycji: {e}")
        return 0

def place_buy_order(product_id, amount, price):
    """Złóż zlecenie kupna dla danej pary."""
    try:
        if not can_open_new_position():
            logger.info("Nie można otworzyć nowej pozycji - przekroczono maksymalną ekspozycję")
            return None
            
        if not can_trade_today(product_id):
            logger.info(f"Osiągnięto dzienny limit transakcji dla {product_id}")
            return None
            
        # Sprawdź dostępne środki
        if product_id.endswith('USDC'):
            available_capital = get_available_balance('USDC')
        else:
            available_capital = get_available_balance('USD')
            
        if available_capital < amount:
            logger.info(f"Za mało dostępnych środków: {available_capital} < {amount}")
            return None
            
        trade_size = calculate_trade_size(product_id, price, 0)  # Domyślny sentyment 0
        if trade_size == 0:
            logger.info(f"Za mało kapitału na zlecenie dla {product_id}")
            return None
            
        crypto_amount = trade_size / price
        logger.info(f"Próba złożenia zlecenia kupna dla {product_id}: {crypto_amount} {product_id.split('-')[0]} (wartość: {trade_size} USDC)")
        
        order = client.create_order(
            client_order_id=str(int(time.time() * 1000)),
            product_id=product_id,
            side="BUY",
            order_configuration={
                "market_market_ioc": {
                    "quote_size": str(trade_size)
                }
            }
        )
        
        market_data[product_id]['last_buy_price'] = price
        market_data[product_id]['highest_price'] = price
        market_data[product_id]['trade_history'].append({
            'type': 'buy',
            'price': price,
            'amount': crypto_amount,
            'timestamp': datetime.utcnow()
        })
        save_trade_history()
        logger.info(f"Złożono zlecenie kupna dla {product_id}: {order}")
        return order
    except Exception as e:
        logger.error(f"Błąd podczas składania zlecenia kupna dla {product_id}: {e}")
        raise

def place_sell_order(product_id, amount, price):
    """Złóż zlecenie sprzedaży dla danej pary."""
    try:
        order = client.create_order(
            client_order_id=str(int(time.time() * 1000)),
            product_id=product_id,
            side="SELL",
            order_configuration={
                "market_market_ioc": {
                    "base_size": str(amount)
                }
            }
        )
        market_data[product_id]['last_sell_price'] = price
        market_data[product_id]['trade_history'].append({
            'type': 'sell',
            'price': price,
            'amount': amount,
            'timestamp': datetime.utcnow()
        })
        save_trade_history()  # Zapisz zmiany po każdej transakcji
        logger.info(f"Złożono zlecenie sprzedaży dla {product_id}: {order}")
        return order
    except Exception as e:
        logger.error(f"Błąd podczas składania zlecenia sprzedaży dla {product_id}: {e}")
        raise

def get_all_balances():
    """Pobierz wszystkie salda konta."""
    try:
        accounts = client.get_accounts().accounts
        balances = {}
        for account in accounts:
            if hasattr(account, 'available_balance') and account.available_balance:
                currency = account.currency
                # Sprawdź czy waluta jest obsługiwana
                if currency not in ['USDC', 'USD', 'BTC', 'ETH']:
                    continue
                    
                # Obsługa różnych formatów danych
                if isinstance(account.available_balance, dict):
                    available = float(account.available_balance.get('value', 0))
                else:
                    available = float(account.available_balance.value)
                
                if hasattr(account, 'total_balance'):
                    if isinstance(account.total_balance, dict):
                        total = float(account.total_balance.get('value', 0))
                    else:
                        total = float(account.total_balance.value)
                else:
                    total = available
                
                if hasattr(account, 'hold'):
                    if isinstance(account.hold, dict):
                        hold = float(account.hold.get('value', 0))
                    else:
                        hold = float(account.hold.value)
                else:
                    hold = 0

                balances[currency] = {
                    'available': available,
                    'total': total,
                    'hold': hold,
                    'currency': currency,
                    'type': getattr(account, 'type', 'unknown'),
                    'active': getattr(account, 'active', True)
                }
        return balances
    except Exception as e:
        logger.error(f"Błąd podczas pobierania sald: {e}")
        raise

def print_detailed_balances():
    """Wyświetla szczegółowe informacje o saldach konta."""
    try:
        print("\n=== SPRAWDZANIE SALD KONTA ===")
        print("Pobieranie danych...")
        
        balances = get_all_balances()
        if not balances:
            print("Nie udało się pobrać sald - brak danych")
            return
            
        print("\n{:<10} {:<15} {:<15} {:<15} {:<15}".format(
            "Waluta", "Dostępne", "Całkowite", "Zablokowane", "Stakowane"
        ))
        print("-" * 75)
        
        total_value_usdc = 0
        
        for currency, data in balances.items():
            try:
                available = float(data['available'])
                total = float(data['total'])
                hold = float(data['hold'])
                staked = float(data['staked'])
                
                # Jeśli to nie USDC, sprawdź czy para handlowa istnieje
                if currency != 'USDC':
                    pair = f"{currency}-USDC"
                    if pair in TRADING_PAIRS:
                        try:
                            current_price = get_product_ticker(pair)
                            if current_price is not None:
                                value_usdc = total * current_price
                                total_value_usdc += value_usdc
                            else:
                                value_usdc = 0
                        except:
                            value_usdc = 0
                    else:
                        value_usdc = 0
                else:
                    value_usdc = total
                    total_value_usdc += value_usdc
                
                print("{:<10} {:<15.8f} {:<15.8f} {:<15.8f} {:<15.8f}".format(
                    currency,
                    available,
                    total,
                    hold,
                    staked
                ))
                
                if currency != 'USDC' and value_usdc > 0:
                    print(f"Wartość w USDC: {value_usdc:.2f}")
                    
            except Exception as e:
                print(f"Błąd przy przetwarzaniu salda {currency}: {e}")
                continue
        
        print("\n=== PODSUMOWANIE ===")
        print(f"Całkowita wartość w USDC: {total_value_usdc:.2f}")
        print("=========================")
        
    except Exception as e:
        print(f"Błąd podczas pobierania sald: {str(e)}")
        print(f"Typ błędu: {type(e).__name__}")
        import traceback
        print(f"Traceback: {traceback.format_exc()}")

def get_transaction_history(product_id):
    """Pobiera historię transakcji dla danej pary."""
    try:
        logger.info(f"\n=== HISTORIA TRANSAKCJI DLA {product_id} ===")
        logger.info("Pobieranie danych...")
        
        fills = client.get_fills(product_id=product_id, limit=100)
        if not fills or not hasattr(fills, 'fills'):
            logger.info("Brak historii transakcji")
            return []
            
        if not fills.fills:
            logger.info("Brak transakcji dla tej pary")
            return []
            
        logger.info(f"\nZnaleziono {len(fills.fills)} transakcji:")
        logger.info("\n{:<20} {:<10} {:<15} {:<15} {:<15} {:<10}".format(
            "Data", "Typ", "Cena", "Ilość", "Wartość", "Opłata"
        ))
        logger.info("-" * 90)
        
        transactions = []
        for fill in fills.fills:
            try:
                timestamp = getattr(fill, 'trade_time', None)
                if timestamp is None:
                    continue
                    
                typ = 'BUY' if getattr(fill, 'side', '-') == 'BUY' else 'SELL'
                cena = float(getattr(fill, 'price', 0))
                ilosc = float(getattr(fill, 'size', 0))
                wartosc = cena * ilosc
                oplata = getattr(fill, 'fee', '0')
                
                transaction = {
                    'timestamp': timestamp,
                    'type': typ,
                    'price': cena,
                    'amount': ilosc,
                    'value': wartosc,
                    'fee': oplata
                }
                transactions.append(transaction)
                
                logger.info("{:<20} {:<10} {:<15.8f} {:<15.8f} {:<15.2f} {:<10}".format(
                    str(timestamp),
                    typ,
                    cena,
                    ilosc,
                    wartosc,
                    str(oplata)
                ))
            except Exception as e:
                logger.error(f"Błąd przy przetwarzaniu transakcji: {e}")
                continue
                
        logger.info("\n=========================")
        return transactions
    except Exception as e:
        logger.error(f"Błąd podczas pobierania historii transakcji dla {product_id}: {e}")
        return []

def get_authenticated_client():
    """Tworzy i zwraca uwierzytelnionego klienta Coinbase."""
    try:
        # Wczytaj klucze API z pliku
        with open('cdp_api_key.json', 'r') as f:
            api_keys = json.load(f)
            api_key = api_keys['api_key_id']
            api_secret = api_keys['api_key_secret']
        
        # Utwórz klienta z kluczami API
        client = RESTClient(api_key=api_key, api_secret=api_secret)
        return client
    except Exception as e:
        logger.error(f"Błąd podczas tworzenia klienta: {str(e)}")
        return None

def save_trade_history():
    """Zapisuje historię transakcji do pliku."""
    try:
        with open('trade_history.json', 'w') as f:
            json.dump(market_data, f, default=str)
        logger.info("Zapisano historię transakcji")
    except Exception as e:
        logger.error(f"Błąd podczas zapisywania historii transakcji: {e}")

def load_trade_history():
    """Wczytuje historię transakcji z pliku."""
    try:
        if os.path.exists('trade_history.json'):
            with open('trade_history.json', 'r') as f:
                data = json.load(f)
                for pair in TRADING_PAIRS:
                    if pair in data:
                        market_data[pair]['trade_history'] = data[pair]['trade_history']
                        # Konwertuj stringi timestampów z powrotem na obiekty datetime
                        for trade in market_data[pair]['trade_history']:
                            trade['timestamp'] = datetime.fromisoformat(trade['timestamp'])
            logger.info("Wczytano historię transakcji")
            return data
        return {}
    except Exception as e:
        logger.error(f"Błąd podczas wczytywania historii transakcji: {e}")
        return {}

def get_product_candles(product_id, start, end, granularity):
    """Pobiera świeczki dla danej pary handlowej."""
    try:
        # Konwertuj daty na timestamp w sekundach
        start_timestamp = int(start.timestamp())
        end_timestamp = int(end.timestamp())
        
        # Użyj prawidłowej metody API
        response = client.get_candles(
            product_id=product_id,
            start=start_timestamp,
            end=end_timestamp,
            granularity=granularity
        )
        
        if not response or not hasattr(response, 'candles'):
            logger.warning(f"Brak danych świeczek dla {product_id}")
            return None
            
        return response.candles
        
    except Exception as e:
        logger.error(f"Błąd podczas pobierania świeczek dla {product_id}: {e}")
        return None

def calculate_market_sentiment(product_id):
    """Analizuje sentyment rynku na podstawie różnych wskaźników."""
    try:
        historical_data = get_historical_data(product_id)
        if historical_data is None or len(historical_data) < 50:
            return 0

        # Oblicz wskaźniki
        rsi = calculate_rsi(historical_data['price'])
        macd, signal, hist = calculate_macd(historical_data['price'])
        ma20, ma50 = calculate_moving_averages(historical_data['price'])
        volatility = calculate_volatility(historical_data)
        
        # Konwertuj wskaźniki na float
        rsi = float(rsi.iloc[-1]) if hasattr(rsi, 'iloc') else float(rsi[-1])
        macd = float(macd.iloc[-1]) if hasattr(macd, 'iloc') else float(macd[-1])
        signal = float(signal.iloc[-1]) if hasattr(signal, 'iloc') else float(signal[-1])
        ma20 = float(ma20.iloc[-1]) if hasattr(ma20, 'iloc') else float(ma20[-1])
        ma50 = float(ma50.iloc[-1]) if hasattr(ma50, 'iloc') else float(ma50[-1])
        volatility = float(volatility.iloc[-1]) if hasattr(volatility, 'iloc') else float(volatility[-1])
        
        # Oblicz głębokość rynku
        market_depth = calculate_market_depth(product_id)
        if market_depth:
            depth_ratio = float(market_depth['ratio'])
        else:
            depth_ratio = 1.0

        # Oblicz sentyment (wartość od -1 do 1)
        sentiment = 0
        
        # RSI contribution
        if rsi < 30:
            sentiment += 0.2
        elif rsi > 70:
            sentiment -= 0.2
            
        # MACD contribution
        if macd > signal:
            sentiment += 0.2
        else:
            sentiment -= 0.2
            
        # Moving Averages contribution
        if ma20 > ma50:
            sentiment += 0.2
        else:
            sentiment -= 0.2
            
        # Volatility contribution
        if volatility < 1.0:  # Niska zmienność
            sentiment += 0.1
        elif volatility > 3.0:  # Wysoka zmienność
            sentiment -= 0.1
            
        # Market depth contribution
        if depth_ratio > 1.2:  # Więcej kupujących
            sentiment += 0.2
        elif depth_ratio < 0.8:  # Więcej sprzedających
            sentiment -= 0.2
            
        return sentiment
        
    except Exception as e:
        logger.error(f"Błąd podczas obliczania sentymentu rynku: {e}")
        return 0

def calculate_position_size(product_id, current_price, sentiment):
    """Oblicza optymalny rozmiar pozycji na podstawie sentymentu i zarządzania ryzykiem."""
    try:
        # Pobierz dostępny kapitał dla pary
        available_capital = get_available_capital_for_pair(product_id)
        
        # Pobierz historię transakcji
        trade_history = market_data[product_id]['trade_history']
        
        # Oblicz dzienny P&L
        daily_pnl = 0
        today = datetime.utcnow().date()
        for trade in trade_history:
            trade_date = datetime.strptime(trade['timestamp'], '%Y-%m-%d %H:%M:%S.%f').date()
            if trade_date == today:
                if trade['type'] == 'sell':
                    daily_pnl += (trade['price'] - market_data[product_id]['last_buy_price']) * trade['amount']
                else:
                    daily_pnl -= trade['price'] * trade['amount']
        
        # Dostosuj rozmiar pozycji na podstawie sentymentu
        base_size = TRADE_VALUE_USDC
        
        # Zmniejsz rozmiar jeśli sentyment jest negatywny
        if sentiment < -0.5:
            base_size *= 0.5
        elif sentiment < 0:
            base_size *= 0.75
            
        # Zmniejsz rozmiar jeśli dzienny P&L jest ujemny
        if daily_pnl < 0:
            base_size *= 0.5
            
        # Sprawdź maksymalny rozmiar pozycji
        max_size = min(available_capital, MAX_POSITION_SIZE)
        
        # Zwróć mniejszą z wartości
        return min(base_size, max_size)
        
    except Exception as e:
        logger.error(f"Błąd podczas obliczania rozmiaru pozycji: {e}")
        return MIN_TRADE_SIZE_USDC

def implement_trailing_stop(product_id, current_price):
    """Implementuje trailing stop dla otwartych pozycji."""
    try:
        trade_history = market_data[product_id]['trade_history']
        if not trade_history:
            return False
            
        # Znajdź ostatnią transakcję kupna
        last_buy = None
        for trade in reversed(trade_history):
            if trade['type'] == 'buy':
                last_buy = trade
                break
                
        if not last_buy:
            return False
            
        # Oblicz zysk
        profit_percent = (current_price - last_buy['price']) / last_buy['price'] * 100
        
        # Jeśli zysk przekracza trailing stop, zaktualizuj stop loss
        if profit_percent > TRAILING_STOP_PERCENT:
            new_stop_price = current_price * (1 - TRAILING_STOP_PERCENT/100)
            
            # Jeśli cena spadła poniżej nowego stop loss, sprzedaj
            if current_price < new_stop_price:
                amount = last_buy['amount']
                place_sell_order(product_id, amount, current_price)
                logger.info(f"Wykonano trailing stop dla {product_id} przy cenie {current_price}")
                return True
                
        return False
        
    except Exception as e:
        logger.error(f"Błąd podczas implementacji trailing stop: {e}")
        return False

def analyze_correlation():
    """Analizuje korelację między kryptowalutami."""
    try:
        correlations = {}
        for pair in TRADING_PAIRS:
            historical_data = get_historical_data(pair)
            if historical_data is not None:
                correlations[pair] = historical_data['price']
                
        # Oblicz korelację między parami
        correlation_matrix = pd.DataFrame(correlations).corr()
        
        # Znajdź pary z wysoką korelacją
        high_correlation_pairs = []
        for i in range(len(correlation_matrix.columns)):
            for j in range(i+1, len(correlation_matrix.columns)):
                if abs(correlation_matrix.iloc[i,j]) > 0.7:  # Korelacja powyżej 0.7
                    high_correlation_pairs.append({
                        'pair1': correlation_matrix.columns[i],
                        'pair2': correlation_matrix.columns[j],
                        'correlation': correlation_matrix.iloc[i,j]
                    })
                    
        return high_correlation_pairs
        
    except Exception as e:
        logger.error(f"Błąd podczas analizy korelacji: {e}")
        return []

def analyze_market_conditions():
    """Analizuje ogólne warunki rynkowe."""
    try:
        market_conditions = {
            'volatility': {},
            'trend': {},
            'sentiment': {},
            'correlation': [],
            'risk_level': 'NORMAL'
        }
        
        # Analizuj każdą parę
        for pair in TRADING_PAIRS:
            historical_data = get_historical_data(pair)
            if historical_data is not None and not historical_data.empty:
                # Oblicz zmienność
                volatility = calculate_volatility(historical_data)
                if hasattr(volatility, 'iloc'):
                    volatility = float(volatility.iloc[-1])
                market_conditions['volatility'][pair] = volatility
                
                # Analizuj trend
                trend = analyze_market_trend(historical_data)
                market_conditions['trend'][pair] = trend
                
                # Oblicz sentyment
                sentiment = calculate_market_sentiment(pair)
                market_conditions['sentiment'][pair] = sentiment
                
        # Analizuj korelacje
        market_conditions['correlation'] = analyze_correlation()
        
        # Określ poziom ryzyka
        high_volatility_count = sum(1 for v in market_conditions['volatility'].values() if float(v) > 3.0)
        negative_sentiment_count = sum(1 for s in market_conditions['sentiment'].values() if float(s) < -0.5)
        
        if high_volatility_count >= 2 or negative_sentiment_count >= 2:
            market_conditions['risk_level'] = 'HIGH'
        elif high_volatility_count >= 1 or negative_sentiment_count >= 1:
            market_conditions['risk_level'] = 'MEDIUM'
            
        return market_conditions
        
    except Exception as e:
        logger.error(f"Błąd podczas analizy warunków rynkowych: {e}")
        logger.error(f"Błąd w głównej pętli: {str(e)}")
        time.sleep(60)
        
    except Exception as e:
        logger.error(f"Krytyczny błąd: {str(e)}")
        raise

def check_buy_conditions(product_id):
    """Sprawdza warunki kupna dla danej pary."""
    try:
        if product_id not in market_data:
            return True
            
        # Sprawdź warunki handlowe
        if not check_trading_conditions(product_id):
            return False
            
        # Pobierz dane historyczne
        historical_data = get_historical_data(product_id)
        if historical_data is None or historical_data.empty:
            logger.error(f"Brak danych historycznych dla {product_id}")
            return False
            
        # Pobierz aktualną cenę
        current_price = get_current_price(product_id)
        if not current_price:
            logger.error(f"Nie udało się pobrać aktualnej ceny dla {product_id}")
            return False
            
        try:
            current_price = float(current_price)
        except (ValueError, TypeError) as e:
            logger.error(f"Błąd podczas konwersji aktualnej ceny: {e}")
            return False
            
        # Oblicz wskaźniki techniczne
        rsi = calculate_rsi(historical_data)
        macd = calculate_macd(historical_data)
        ma_short = calculate_moving_average(historical_data, 20)
        ma_long = calculate_moving_average(historical_data, 50)
        volatility = calculate_volatility(historical_data)
        
        # Sprawdź warunki kupna
        if rsi < 30:  # Przesprzedany
            logger.info(f"RSI wskazuje na przesprzedanie: {rsi}")
            return True
            
        if macd > 0 and ma_short > ma_long:  # Trend wzrostowy
            logger.info("Wskaźniki wskazują na trend wzrostowy")
            return True
            
        if volatility < MAX_VOLATILITY * 0.5:  # Niska zmienność
            logger.info(f"Zmienność jest akceptowalna: {volatility}")
            return True
            
        return False
        
    except Exception as e:
        logger.error(f"Błąd podczas sprawdzania warunków kupna: {e}")
        return False

def check_sell_conditions(product_id):
    """Sprawdza warunki sprzedaży dla danej pary."""
    try:
        if product_id not in market_data:
            return True
            
        # Sprawdź warunki handlowe
        if not check_trading_conditions(product_id):
            return False
            
        # Pobierz dane historyczne
        historical_data = get_historical_data(product_id)
        if historical_data is None or historical_data.empty:
            logger.error(f"Brak danych historycznych dla {product_id}")
            return False
            
        # Pobierz aktualną cenę
        current_price = get_current_price(product_id)
        if not current_price:
            logger.error(f"Nie udało się pobrać aktualnej ceny dla {product_id}")
            return False
            
        try:
            current_price = float(current_price)
        except (ValueError, TypeError) as e:
            logger.error(f"Błąd podczas konwersji aktualnej ceny: {e}")
            return False
            
        # Oblicz wskaźniki techniczne
        rsi = calculate_rsi(historical_data)
        macd = calculate_macd(historical_data)
        ma_short = calculate_moving_average(historical_data, 20)
        ma_long = calculate_moving_average(historical_data, 50)
        volatility = calculate_volatility(historical_data)
        
        # Sprawdź warunki sprzedaży
        if rsi > 70:  # Przesprzedany
            logger.info(f"RSI zbyt wysoki: {rsi}")
            return True
            
        if macd < 0 and ma_short < ma_long:  # Trend spadkowy
            logger.info("Wskaźniki wskazują na trend spadkowy")
            return True
            
        if volatility > MAX_VOLATILITY:  # Wysoka zmienność
            logger.info("Zmienność jest zbyt wysoka")
            return True
            
        return False
        
    except Exception as e:
        logger.error(f"Błąd podczas sprawdzania warunków sprzedaży: {e}")
        return False

def check_trading_conditions(product_id):
    """Sprawdza warunki handlowe dla danej pary."""
    try:
        if product_id not in market_data:
            return True
            
        # Sprawdź wszystkie limity
        if not check_all_limits(product_id):
            return False
            
        # Sprawdź warunki rynkowe
        if not check_market_conditions(product_id):
            return False
            
        # Pobierz historię transakcji
        trade_history = market_data[product_id]['trade_history']
        if not trade_history:
            return True
            
        # Znajdź ostatnią transakcję
        last_trade = trade_history[-1]
        if not isinstance(last_trade['timestamp'], datetime):
            logger.error("Nieprawidłowy format czasu ostatniej transakcji")
            return False
            
        # Sprawdź czas od ostatniej transakcji
        time_since_last_trade = datetime.utcnow() - last_trade['timestamp']
        if time_since_last_trade.total_seconds() < MIN_TIME_BETWEEN_TRADES:
            logger.warning(f"Zbyt krótki czas od ostatniej transakcji: {time_since_last_trade.total_seconds()}s (minimum: {MIN_TIME_BETWEEN_TRADES}s)")
            return False
            
        # Sprawdź typ ostatniej transakcji
        if last_trade['type'] == 'buy':
            # Jeśli ostatnia transakcja to kupno, sprawdź czy minął wystarczający czas
            if time_since_last_trade.total_seconds() < MIN_HOLDING_TIME:
                logger.warning(f"Zbyt krótki czas trzymania pozycji: {time_since_last_trade.total_seconds()}s (minimum: {MIN_HOLDING_TIME}s)")
                return False
                
        return True
        
    except Exception as e:
        logger.error(f"Błąd podczas sprawdzania warunków handlowych: {e}")
        return False

def check_daily_pnl():
    """Sprawdza dzienny P&L dla wszystkich par handlowych"""
    try:
        total_pnl = 0
        for pair in TRADING_PAIRS:
            # Pobierz historię transakcji dla pary
            trades = get_transaction_history(pair)
            if not trades:
                continue
                
            # Filtruj transakcje z dzisiejszego dnia
            today = datetime.now().date()
            today_trades = []
            
            for trade in trades:
                try:
                    # Konwertuj timestamp na datetime jeśli jest stringiem
                    if isinstance(trade['timestamp'], str):
                        trade_date = datetime.fromisoformat(trade['timestamp'].replace('Z', '+00:00')).date()
                    else:
                        trade_date = trade['timestamp'].date()
                        
                    if trade_date == today:
                        today_trades.append(trade)
                except Exception as e:
                    logger.error(f"Błąd podczas przetwarzania transakcji: {e}")
                    continue
            
            # Oblicz P&L dla dzisiejszych transakcji
            for trade in today_trades:
                amount = float(trade['amount'])
                price = float(trade['price'])
                if trade['type'] == 'BUY':
                    total_pnl -= amount * price
                else:  # SELL
                    total_pnl += amount * price
                    
        return total_pnl
    except Exception as e:
        logger.error(f"Błąd podczas sprawdzania dziennego P&L: {e}")
        return 0

def calculate_pnl_limit():
    """Oblicza limit dziennego P&L."""
    try:
        return MAX_TOTAL_EXPOSURE * MAX_LOSS_PERCENT / 100
    except Exception as e:
        logger.error(f"Błąd podczas obliczania limitu dziennego P&L: {e}")
        return 0

def calculate_volatility_limit():
    """Oblicza limit zmienności."""
    try:
        return MAX_TOTAL_EXPOSURE * MAX_LOSS_PERCENT / 100
    except Exception as e:
        logger.error(f"Błąd podczas obliczania limitu zmienności: {e}")
        return 0

def calculate_rsi_limit():
    """Oblicza limit RSI."""
    try:
        return MAX_TOTAL_EXPOSURE * MAX_LOSS_PERCENT / 100
    except Exception as e:
        logger.error(f"Błąd podczas obliczania limitu RSI: {e}")
        return 0

def calculate_macd_limit():
    """Oblicza limit MACD."""
    try:
        return MAX_TOTAL_EXPOSURE * MAX_LOSS_PERCENT / 100
    except Exception as e:
        logger.error(f"Błąd podczas obliczania limitu MACD: {e}")

def check_stop_loss(product_id):
    """Sprawdza warunki stop loss dla danej pary."""
    try:
        if product_id not in market_data:
            return True
            
        # Pobierz historię transakcji
        trade_history = market_data[product_id]['trade_history']
        if not trade_history:
            return True
            
        # Znajdź ostatnią transakcję kupna
        last_buy = None
        for trade in reversed(trade_history):
            if trade['type'] == 'buy':
                last_buy = trade
                break
                
        if not last_buy:
            return True
            
        # Pobierz aktualną cenę
        current_price = get_current_price(product_id)
        if not current_price:
            logger.error(f"Nie udało się pobrać aktualnej ceny dla {product_id}")
            return False
            
        try:
            current_price = float(current_price)
            last_buy_price = float(last_buy['price'])
        except (ValueError, TypeError) as e:
            logger.error(f"Błąd podczas konwersji wartości: {e}")
            return False
            
        # Oblicz procentową zmianę ceny
        price_change = (current_price - last_buy_price) / last_buy_price * 100
        
        # Sprawdź warunki stop loss
        if price_change <= -STOP_LOSS_PERCENT:
            logger.warning(f"Stop loss osiągnięty: {price_change}% (limit: -{STOP_LOSS_PERCENT}%)")
            return True
            
        return False
        
    except Exception as e:
        logger.error(f"Błąd podczas sprawdzania warunków stop loss: {e}")
        return False

def check_take_profit(product_id):
    """Sprawdza warunki take profit dla danej pary."""
    try:
        if product_id not in market_data:
            return True
            
        # Pobierz historię transakcji
        trade_history = market_data[product_id]['trade_history']
        if not trade_history:
            return True
            
        # Znajdź ostatnią transakcję kupna
        last_buy = None
        for trade in reversed(trade_history):
            if trade['type'] == 'buy':
                last_buy = trade
                break
                
        if not last_buy:
            return True
            
        # Pobierz aktualną cenę
        current_price = get_current_price(product_id)
        if not current_price:
            logger.error(f"Nie udało się pobrać aktualnej ceny dla {product_id}")
            return False
            
        try:
            current_price = float(current_price)
            last_buy_price = float(last_buy['price'])
        except (ValueError, TypeError) as e:
            logger.error(f"Błąd podczas konwersji wartości: {e}")
            return False
            
        # Oblicz procentową zmianę ceny
        price_change = (current_price - last_buy_price) / last_buy_price * 100
        
        # Sprawdź warunki take profit
        if price_change >= TAKE_PROFIT_PERCENT:
            logger.info(f"Take profit osiągnięty: {price_change}% (limit: {TAKE_PROFIT_PERCENT}%)")
            return True
            
        return False
        
    except Exception as e:
        logger.error(f"Błąd podczas sprawdzania warunków take profit: {e}")
        return False

def check_trailing_stop(product_id):
    """Sprawdza warunki trailing stop dla danej pary."""
    try:
        if product_id not in market_data:
            return True
            
        # Pobierz historię transakcji
        trade_history = market_data[product_id]['trade_history']
        if not trade_history:
            return True
            
        # Znajdź ostatnią transakcję kupna
        last_buy = None
        for trade in reversed(trade_history):
            if trade['type'] == 'buy':
                last_buy = trade
                break
                
        if not last_buy:
            return True
            
        # Pobierz aktualną cenę
        current_price = get_current_price(product_id)
        if not current_price:
            logger.error(f"Nie udało się pobrać aktualnej ceny dla {product_id}")
            return False
            
        try:
            current_price = float(current_price)
            last_buy_price = float(last_buy['price'])
        except (ValueError, TypeError) as e:
            logger.error(f"Błąd podczas konwersji wartości: {e}")
            return False
            
        # Oblicz procentową zmianę ceny
        price_change = (current_price - last_buy_price) / last_buy_price * 100
        
        # Sprawdź warunki trailing stop
        if price_change <= -TRAILING_STOP_PERCENT:
            logger.warning(f"Trailing stop osiągnięty: {price_change}% (limit: -{TRAILING_STOP_PERCENT}%)")
            return True
            
        return False
        
    except Exception as e:
        logger.error(f"Błąd podczas sprawdzania warunków trailing stop: {e}")
        return False

def check_all_conditions(product_id):
    """Sprawdza wszystkie warunki dla danej pary."""
    try:
        if product_id not in market_data:
            return True
            
        # Sprawdź warunki handlowe
        if not check_trading_conditions(product_id):
            return False
            
        # Sprawdź warunki rynkowe
        if not check_market_conditions(product_id):
            return False
            
        # Sprawdź warunki kupna
        if not check_buy_conditions(product_id):
            return False
            
        # Sprawdź warunki sprzedaży
        if not check_sell_conditions(product_id):
            return False
            
        # Sprawdź warunki stop loss
        if not check_stop_loss(product_id):
            return False
            
        # Sprawdź warunki take profit
        if not check_take_profit(product_id):
            return False
            
        # Sprawdź warunki trailing stop
        if not check_trailing_stop(product_id):
            return False
            
        return True
        
    except Exception as e:
        logger.error(f"Błąd podczas sprawdzania wszystkich warunków: {e}")
        return False

if __name__ == "__main__":
    main()




